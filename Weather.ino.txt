// -----------------------------------------------------------------------------------------------------------------
// Weather functions
// this is the Weather.ino file for my setup

// the see the SparkFun, Adafruit, etc. product setup guides to find the libraries and instructions for installing them
#include <Wire.h>
#include <Adafruit_Sensor.h>

bool skyGood=false;
#include <Adafruit_MLX90614.h>
Adafruit_MLX90614 mlx = Adafruit_MLX90614();

bool pressureGood=false;
#include <SFE_BMP180.h>
SFE_BMP180 pressure;
#define DEBUG_WEATHER_OFF

bool tempHumidityGood=false;
#include <Adafruit_Si7021.h>
Adafruit_Si7021 tempHumidity = Adafruit_Si7021();

bool skyQualityGood=false;
#include <Adafruit_TSL2591.h> // my customized version from https://github.com/hjd1964/Adafruit_TSL2591_Library
Adafruit_TSL2591 tsl = Adafruit_TSL2591(2591);

// this gets called once on startup to initialize any weather sensors
void weatherInit() {
  Wire.setClock(20000); // slow down i2c so long distances work, still plenty fast for our little data being moved around
  analogReference(DEFAULT);

  // wiring has pullups enabled, for a 3.3V I2C device this isn't a good thing
  // even this hack isn't 100% perfect since 5V is applied for an instant at startup
  // use a level converter if this causes you to loose sleep

#ifdef DEBUG_WEATHER_ON
  Serial.println("Debug weather start");
#endif

  tempHumidity.begin(); tempHumidityGood=true;
  pinMode(20,INPUT); pinMode(21,INPUT);
#ifdef DEBUG_WEATHER_ON
  if (tempHumidityGood) Serial.println("TEMP HUMD up"); else Serial.println("TEMP HUMD fail");
#endif
  
  if (pressure.begin()) pressureGood=true;
  pinMode(20,INPUT); pinMode(21,INPUT);
#ifdef DEBUG_WEATHER_ON
  if (pressureGood) Serial.println("PRESSURE up"); else Serial.println("PRESSURE fail");
#endif

  mlx.begin(); skyGood=true;
  pinMode(20,INPUT); pinMode(21,INPUT);
#ifdef DEBUG_WEATHER_ON
  if (skyGood) Serial.println("SKY IR up"); else Serial.println("SKY IR fail");
#endif

  if (tsl.begin()) skyQualityGood=true;
  tsl.setGain(TSL2591_GAIN_MED);                   // 1x _LOW, 25x _MED, 428x _HIGH, 9876x _MAX (higher gain = more sensitivity)
  tsl.setTiming(TSL2591_INTEGRATIONTIME_300MS);    // _100MS, _200MS, _300MS, _400MS, _500MS, _600MS (higher integration time = more sensitivity)
#ifdef DEBUG_WEATHER_ON
  if (skyQualityGood) Serial.println("SKY QUAL up"); else Serial.println("SKY QUAL fail");
#endif
}

// gets outside temperature in deg. C
// return (invalid) if not implemented or if there's an error
double weatherOutsideTemp() {
  if (!tempHumidityGood) return invalid;
  double t = tempHumidity.readTemperature();
  if (t<-60.0 || t>60.0) t=invalid;
  return t;
}

// gets sky IR temperature in deg. C
// return (invalid) if not implemented or if there's an error
double weatherSkyTemp() {
  if (!skyGood) return (invalid);
  double t = mlx.readObjectTempC(); 
  if (t<-100.0 || t>100.0) t=invalid;
  return t;
}

// gets windspeed in kph
// return (invalid) if not implemented or if there's an error
double weatherWindspeed() {
  // for the Modern Devices wind sensor, https://moderndevice.com/product/wind-sensor-rev-p/
  const int OutPin = A6;   // wind sensor analog pin hooked up to Wind P sensor "OUT" pin
  int windADunits = analogRead(OutPin);
  double windMPH = pow((((float)windADunits - 264.0) / 85.6814), 3.36814);
  if (isnan(windMPH)) windMPH=0;
  double windKPH = windMPH * 1.60934;
// Temperature compensation isn't implemented
// const int TempPin = A7;   // temp sensor analog pin hooked up to Wind P sensor "TMP" pin
// int tempRawAD = analogRead(TempPin);
// double tempC = ((((float)tempRawAD * 5.0) / 1024.0) - 0.400) / .0195;
  if (windKPH<0 || windKPH>350) windKPH=invalid;
  return (windKPH);
}

// gets absolute barometric pressure in mb (not sea-level adjusted)
// return (invalid) if not implemented or if there's an error
double weatherPressure() {
  if (!pressureGood) return (invalid);

  char status;
  double T,P,p0,a;
  p0=-1000;
  status = pressure.startTemperature();
  if (status != 0)
  {
    delay(status); // Wait for the measurement to complete

    // Retrieve the completed temperature measurement:
    // Note that the measurement is stored in the variable T.
    // Function returns 1 if successful, 0 if failure.
    status = pressure.getTemperature(T);
    if (status != 0)
    {
      // Start a pressure measurement:
      // The parameter is the oversampling setting, from 0 to 3 (highest res, longest wait).
      // If request is successful, the number of ms to wait is returned.
      // If request is unsuccessful, 0 is returned.
      status = pressure.startPressure(3);
      if (status != 0)
      {
        delay(status); // Wait for the measurement to complete

        // Retrieve the completed pressure measurement:
        // Note that the measurement is stored in the variable P.
        // Note also that the function requires the previous temperature measurement (T).
        // (If temperature is stable, you can do one temperature measurement for a number of pressure measurements.)
        // Function returns 1 if successful, 0 if failure.
        status = pressure.getPressure(P,T);
        if (status != 0)
        {
          p0=P;
        } else p0=-1003;
      } else p0=-1002;
    } else p0=-1001;
  } else p0=-1000;

#ifdef DEBUG_PRESSURE_ON
  if (p0==-1003) Serial.println("Error retrieving pressure measurement");
  if (p0==-1002) Serial.println("Error starting pressure measurement");
  if (p0==-1001) Serial.println("Error retrieving temperature measurement");
  if (p0==-1000) Serial.println("Error starting temperature measurement");
#endif

  if (p0<invalid) p0=invalid;
  
  return p0;
}

// gets barometric pressure in mb (sea-level adjusted)
// return (invalid) if not implemented or if there's an error
double weatherPressureSeaLevel() {
  {
    double P=weatherPressure();
    if (P==invalid) return P;
    
    // The pressure sensor returns abolute pressure, which varies with altitude.
    // To remove the effects of altitude, use the sealevel function and your current altitude.
    // This number is commonly used in weather reports.
    // Parameters: P = absolute pressure in mb, ALTITUDE = current altitude in m.
    // Result: p0 = sea-level compensated pressure in mb
    double p0 = pressure.sealevel(P,WEATHER_ALTITUDE);
    return p0;
  }
}

// gets relative humidity in %
// return (invalid) if not implemented or if there's an error
double weatherHumidity() {
  if (!tempHumidityGood) return (invalid);
  double h=tempHumidity.readHumidity();
  if (h<0.0) h=invalid;
  if (h>100.0) h=100.0;
  return h;
}

// gets rain sensor info. 1 is Rain, 2 is Warn, and 3 is Dry
// return (invalid) if not implemented or if there's an error
// this is for the typical eBay rain sensor like this one:
// http://www.ebay.com/itm/Raindrops-Detection-sensor-modue-rain-module-weather-module-Humidity-For-Arduino-/400439668701
#define WEATHER_RAIN_THRESHOLD_LOW 0.25
#define WEATHER_RAIN_THRESHOLD_HIGH 0.75
int weatherRain() {
  double rain = (double)analogRead(A2)/1023.0; // scale for 0.0 to 1.0 range

  if (rain <= WEATHER_RAIN_THRESHOLD_LOW) return 1; else
  if (rain > WEATHER_RAIN_THRESHOLD_HIGH) return 3; else return 2;
}

// gets sky brightness in mag/arc-sec^2
// return (invalid) if not implemented or if there's an error
double last_mag_per_sq_arcsec = invalid;
unsigned long last_mag_per_sq_arcsec_time = 0;
double weatherSkyQuality() {
  uint32_t lum;

  // safe-guard to invalidate stale readings after 30 seconds
  if ((long)((last_mag_per_sq_arcsec_time+30000UL)-millis()) < 0) last_mag_per_sq_arcsec = invalid;
  
  // read data from TSL2591 (blocking)
  // this routine blocks for almost a full second in some cases, so fall back to last value if the roof is moving
//  if (roofIsMoving()) return last_mag_per_sq_arcsec;
//  lum = tsl.getFullLuminosity();

  // read data from TSL2591 (non-blocking)
  static int stage = 1;
  if (stage == 1) { tsl.getFullLuminosity(TSL2591_GFL_INIT); stage++; return last_mag_per_sq_arcsec; }
  if (stage == 2) { if (tsl.getFullLuminosity(TSL2591_GFL_WAIT)) return last_mag_per_sq_arcsec; stage++; }
  if (stage == 3) { lum=tsl.getFullLuminosity(TSL2591_GFL_DONE); stage=1; }
  
  uint16_t ir = lum >> 16;
  uint16_t full = lum & 0xFFFF;

  Serial.print(full); Serial.print(", "); Serial.println(ir);

  // automatically adapt gain and integration time
  if (!tsl.autoscale(full, ir)) return last_mag_per_sq_arcsec;
  
  // correct for sensor temperature sensitivity
  double t=weatherOutsideTemp();
  if (t != invalid) {
    full=tsl.temperatureCorrectCh0(t,full);
    ir  =tsl.temperatureCorrectCh1(t,ir);
  }

  // finally get the visible brightness in Lux
  double lux = tsl.calculateLux(full, ir);

  // Lux = Candela at 1 meter.
  // At 1 meter a 1 meter^2 surface has an approximately 60 deg fov so this TSL2591 effectively measures in Candela given a 60 deg TFOV lens.
  // Its sensitivity spread across the 180 deg FOV seems to be about right for 1 Candela with no lens, but I'm not an expert on this!
  // If using a 30 deg TFOV lens, for example, set WEATHER_SKY_QUAL_SCALE 4.0 since light from a smaller surface area is projected onto the sensor.
  double mag_per_sq_arcsec = WEATHER_SKY_QUAL_ZERO + log10((lux * WEATHER_SKY_QUAL_SCALE)/108000.0)/-0.4;
  last_mag_per_sq_arcsec = mag_per_sq_arcsec;
  last_mag_per_sq_arcsec_time = millis();
  
  return (last_mag_per_sq_arcsec);
}
